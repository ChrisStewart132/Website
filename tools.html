<html>
    <head>
        <link rel="stylesheet" href="styles.css">
        <style>
            .wrap {
                margin: 10 40 10 40;
                word-wrap: break-word;
                overflow-wrap: break-word;
                border: 0px solid white;
                padding: 20px;
            }
            input:hover, select:hover {
                background-color: white;
                color: black;
            }
            .dimension {
                display: inline-block;
                margin: 10 0 10 0;
                border: 1px solid white;
                padding: 20px;
            }
            main > div{
                border: 1px solid white;
                margin: 80 20% 10 20%;
                padding: 20px;
            }
        </style>
    </head>



    <body>
        <navbar>
            <a href="index.html">HOME</a>
        </navbar>

        <main>
            <div>
                <h1>TODO LIST</h1><br>
                <span>input</span><input type="text" value="task" id="todoInput">
                <input type="submit" value="ADD TASK"
                 onclick="addTask(document.getElementById(`todoInput`), document.getElementById(`todoList`))"
                 onkeydown="(event)=>{
                    console.log(event)
                    if(event.keyCode == 13){
                        addTask(document.getElementById(`todoInput`), document.getElementById(`todoList`));
                    }
                }"><br>
                <div class="wrap" id="todoList"></div>
            </div>
            <div class="test">
                <div>
                    <h1>TEST GENERATOR</h1><br>
                    DIMENSIONS<br>
                    <input type="number" id="testDimensions" value="1" min="1" onclick="updateDimensions(this)"><br>
                    LENGTH<br>
                    <input type="number" id="testLength" value="10" min="1"><br><br>
                    <!-- constraints e.g. push if x != 3, or xi > xi-1 etc -->
                </div>
                <div class="dimensions">
                    <div class="dimension">
                        MIN<br>
                        <input type="number" value="0"><br><br>
                        MAX<br>
                        <input type="number" value="10"><br><br>
                        TYPE
                        <select name="type">
                            <option value="int">INT</option>
                            <option value="intString">INT STRING</option>
                            <option value="float">FLOAT</option>
                            <option value="floatString">FLOAT STRING</option>
                            <option value="char">CHAR</option>
                            <option value="string">STRING</option>
                            <!--
                                char(lower), char(upper), char (mixed)
                                string(lower), string(upper), string(mixed)
                            -->
                        </select>
                    </div><!--remove whitespace
                --></div>
                <div>
                    <input type="submit" value="GENERATE" onclick="generate()"><br>
                    <p class="wrap" id="testResult">[]</p>
                </div>
            </div>

            <div class="combinatorics">
                <div>
                    <h1>COMBINATORICS</h1><br>
                    <details>
                        <summary>COMBINATORICS SUMMARY</summary>
                        <br><p><h1>Variations</h1> involve selecting or arranging elements from a set where the order matters.</p><br>
                        <p><h1>Permutations</h1> involve arranging all the elements of a set in all possible orders.</p><br>
                        <p><h1>Combinations</h1> involve selecting elements from a set where the order does not matter.</p>  <br>           
                    </details><br>   
                    <select name="type" id="combinatoricsSetting">
                        <option value="variations">VARIATIONS</option>
                        <option value="permutations">PERMUTATIONS</option>
                        <option value="combinations">COMBINATIONS</option>
                    </select><br><br>
                    MAX LENGTH<br>
                    <input type="number" id="combinatoricsLength" value="4" min="1" max="10"><br><br>
                </div>
                <input type="text" value="0,1" id="combinatoricsSymbols"><br><br>
                <div>
                    <input type="submit" value="GENERATE" onclick="generateCombinatorics()"><br>
                    <p class="wrap" id="combinatoricsResult">[]</p>
                </div>
            </div>

            <div>
                <h1>INPUT SORTER</h1><br>
                compare(a, b)<br><input style="width:50%; text-align: center;" type="text" value="parseInt(a[0]) > parseInt(b[0]) || parseInt(a[0]) == parseInt(b[0]) && a[1].length > b[1].length" id="sortCompare" title="e.g. a>b or parseInt(a)>parseInt(b) or a[0] > b[0] or a.length < b.length etc"><br><br>
                input<br><input type="text" value="[]" id="sortInput"><br><br>
                <input type="submit" value="SORT" onclick="sort()"><br>
                <p class="wrap" id="sortResult">[]</p>
                <!--
                    sort array 
                    sort sub arrays
                    compare function options (ASC DSC by index i if multi dimensional else index 0) / user input?
                -->
            </div>


            <div>
                <h1>FETCH</h1><br>
                TYPE
                <select name="type" id="fetchType">
                    <option value="get" selected>GET</option>
                    <option value="head">HEAD</option>
                    <option value="post">POST</option>
                    <option value="put">PUT</option>
                    <option value="patch">PATCH</option>
                    <option value="delete">DELETE</option>
                    <option value="options">OPTIONS</option>
                </select>
                URL
                <input type="text" value="https://data-asg.goldprice.org/dbXRates/NZD" style="width:74%; text-align: center;" id="fetchURL"><br><br>                 
                DATA
                <input type="text" value='{"key1":"str", "arr1":["item1", 3.14, false], "obj1":{"key1": null}}' id="fetchData" style="width:80%; text-align: center;" >
                <input type="submit" value="FETCH" onclick="fetchRequest(this)"><br><br>
                RESPONSE HEADER
                <p class="wrap" id="responseHeader">{}</p>
                RESPONSE DATA
                <p class="wrap" id="responseData">{}</p>
                <details>
                    <summary>HTTP Method Summary</summary>
                        <h1>GET</h1>
                        <p>
                            The GET method requests that the target resource transfer a representation of its state. GET requests should only retrieve data and should have no other effect. (This is also true of some other HTTP methods.)[1] For retrieving resources without making changes, GET is preferred over POST, as they can be addressed through a URL. This enables bookmarking and sharing and makes GET responses eligible for caching, which can save bandwidth. The W3C has published guidance principles on this distinction, saying, "Web application design should be informed by the above principles, but also by the relevant limitations."[53] See safe methods below.
                        </p><br>
                        <h1>HEAD</h1>
                        <p>
                            The HEAD method requests that the target resource transfer a representation of its state, as for a GET request, but without the representation data enclosed in the response body. This is useful for retrieving the representation metadata in the response header, without having to transfer the entire representation. Uses include checking whether a page is available through the status code and quickly finding the size of a file (Content-Length).
                        </p><br>
                        <h1>POST</h1>
                        <p>The POST method requests that the target resource process the representation enclosed in the request according to the semantics of the target resource. For example, it is used for posting a message to an Internet forum, subscribing to a mailing list, or completing an online shopping transaction.[54]
                        </p><br>
                        <h1>PUT</h1>
                        <p>
                            The PUT method requests that the target resource create or update its state with the state defined by the representation enclosed in the request. A distinction from POST is that the client specifies the target location on the server.[55]
                        </p><br>
                        <h1>DELETE</h1>
                        <p>
                            The DELETE method requests that the target resource delete its state.
                        </p><br>
                        <h1>CONNECT</h1>
                        <p>
                            The CONNECT method requests that the intermediary establish a TCP/IP tunnel to the origin server identified by the request target. It is often used to secure connections through one or more HTTP proxies with TLS.[56][57] See HTTP CONNECT method.
                        </p><br>
                        <h1>OPTIONS</h1>
                        <p>
                            The OPTIONS method requests that the target resource transfer the HTTP methods that it supports. This can be used to check the functionality of a web server by requesting '*' instead of a specific resource.
                        </p><br>
                        <h1>TRACE</h1>
                        <p>
                            The TRACE method requests that the target resource transfer the received request in the response body. That way a client can see what (if any) changes or additions have been made by intermediaries.
                        </p><br>
                        <h1>PATCH</h1>
                        <p>
                            The PATCH method requests that the target resource modify its state according to the partial update defined in the representation enclosed in the request. This can save bandwidth by updating a part of a file or document without having to transfer it entirely.
                        </p><br>
                </details><br> 
            </div>

            <div style="height: 500px; border: none;">

            </div>
        </main>





        <script>
            // todo list
            function addTask(taskInputElement, listElement){
                //<input type="submit" value="REMOVE TASK"
                 //onclick="addTask(document.getElementById(`todoInput`), document.getElementById(`todoList`))"><br>
                
                const removeElement = document.createElement(`input`);
                removeElement.type = "submit";
                removeElement.value = "REMOVE";
                removeElement.onclick = function(){
                    this.parentElement.remove();
                };

                const taskElement = document.createElement(`span`);
                taskElement.textContent = taskInputElement.value;
                taskElement.style.margin = "30px"

                const divElement = document.createElement(`div`);
                divElement.style.textAlign = "left"
                divElement.style.marginLeft = "33%"
                divElement.append(removeElement)
                divElement.append(taskElement)
                listElement.append(divElement)

                taskInputElement.value = ""
            }

            // fetch requester
            function fetchRequest(inputElement){
                const type = document.getElementById("fetchType").value;
                const url = document.getElementById("fetchURL").value;
                const data = document.getElementById("fetchData").value;
                const responseHeader = document.getElementById("responseHeader")
                const responseData = document.getElementById("responseData")
                responseHeader.textContent=""
                responseData.textContent=""
                console.log(type, url, data)
                options = {
                    method: type, // *GET, POST, PUT, DELETE, etc. 
                }
                if(["post", "put", "patch"].includes(type)){
                    options["headers"] = {
                    //"Content-Type": "text/html",
                    "Content-Type": "application/json",
                    // 'Content-Type': 'application/x-www-form-urlencoded',
                    
                    }
                    options["body"] = (data) // body data type must match "Content-Type" header
                }
                console.log(`options: ${JSON.stringify(options)}`)
                fetch(url, options).then((response) => {
                    console.log('Response status:', response.status);
                    console.log('Response:', response);
                    if(response.headers){
                        console.log('Headers:', response.headers);
                        let headersStr =""
                        const keys = response.headers.keys()
                        response.headers.forEach((v,k) => headersStr+=`"${k}":"${v}", `)
                        responseHeader.textContent = headersStr
                    } 
                    if(options.method == 'head'){
                        return null// return empty response for HEAD requests
                    }
                    return response.json(); // Returns a Promise that resolves with the JSON body content
                }).then((data) => {
                    console.log(data);
                    responseData.textContent = JSON.stringify(data)
                })
            }

            // input sorter
            function sort(){
                let input = document.getElementById("sortInput").value.slice(1,-1);// slice first and last brackets
                //input = input.replace(" ", "")// remove all spaces
                //console.log("input:" + input)
                const sortCompare = document.getElementById("sortCompare").value;
                //console.log("compare: return " + sortCompare);

                if(input[0] === "["){// converting matrix string to js matrix/2d arr
                    var arr = []
                    input.split("],").forEach((row) => {
                        row = row.replace("[", "");
                        row = row.replace("]", "");
                        arr.push(row.split(","))
                    })
                }else{
                    var arr = input.split(",")// convert comma seperated string into an arr
                }
                //console.log(arr)
                const sortedArr = arr.sort((a, b) => {return eval(sortCompare)})
                //console.log(sortedArr)
                const p = document.getElementById("sortResult");
                if(typeof(arr[0]) == "object"){
                    //console.log("matrix")
                    let output = ""
                    sortedArr.forEach((row) => {

                        output += "[" + row + "],";
                    })
                    p.textContent = "[" + output.slice(0,-1) + "]";
                }else{
                    //console.log("arr")
                    p.textContent = "[" + sortedArr + "]";
                }            
            }

            // combinatorics
            function variations(symbols, max_length, output, starting_candidate=""){
                let stack = [starting_candidate]
                while(stack.length > 0){
                    let candidate = stack.pop()
                    if(candidate.length > max_length){
                        continue
                    }
                    output.push(candidate);
                    for(let i = 0; i < symbols.length; i++){
                        let child_candidate = candidate + symbols[i]
                        stack.push(child_candidate)
                    }
                }
            }
            function permutations(symbols, max_length, output, starting_candidate=""){
                let stack = [starting_candidate]
                while(stack.length > 0){
                    let candidate = stack.pop()
                    if(candidate.length > max_length){
                        continue
                    }
                    output.push(candidate);
                    for(let i = 0; i < symbols.length; i++){
                        if(!candidate.includes(symbols[i])){
                            let child_candidate = candidate + symbols[i]
                            stack.push(child_candidate)
                        }
                    }
                }
            }
            function setsAreEqual(set1, set2) {
                if (set1.size !== set2.size) {
                    return false;
                }
                for (let item of set1) {
                    if (!set2.has(item)) {
                        return false;
                    }
                }
                return true;
            }
            function combinations(symbols, max_length, output, starting_candidate="") {
                let p = []
                permutations(symbols, max_length, p, starting_candidate)
                p.shift()
                for(const candidate of p){
                    let s1 = new Set(candidate)
                    let add = true
                    for(const e of output){
                        let s2 = new Set(e)
                        console.log(s2)
                        if(setsAreEqual(s1,s2)){
                            add = false
                            break
                        }
                    }
                    if(add){
                        output.push(candidate)
                    }
                }
            }
            function generateCombinatorics(){
                const p = document.getElementById("combinatoricsResult");
                const max_length = parseInt(document.getElementById("combinatoricsLength").value);
                const setting = document.getElementById("combinatoricsSetting").value
                const symbols = (document.getElementById("combinatoricsSymbols").value).split(",")

                let arr = [];
                if(setting == "variations"){
                    variations(symbols, max_length, arr)
                }else if(setting == "permutations"){
                    permutations(symbols, max_length, arr)
                }else if(setting == "combinations"){
                    combinations(symbols, max_length, arr)
                }
                arr.shift(); // Removes the first empty element
                console.log(arr)
                //let joinedString = arr.toString();
                let joinedString = arr.map(str => `"${str}"`).join(",");
                updateElementText(p, "[" + joinedString + "]")
            }


            // test generator
            updateDimensions(document.getElementById("testDimensions"))
            function updateDimensions(input){
                const container = (document.querySelector(".test")).querySelector(".dimensions")
                let currentDimensions = container.children.length
                const targetDimensions = parseInt(input.value);
                const dimensionElement = container.children[0];// 1 child will always exist
                while(container.children.length < targetDimensions){
                    const clonedDimension = dimensionElement.cloneNode(true);
                    container.append(clonedDimension);
                }
                while(container.children.length > targetDimensions){
                    const lastChild = container.children[container.children.length-1];
                    container.removeChild(lastChild);
                }
            }
            function getRandomInt(min, max) {
                return Math.round(Math.random() * (max - min)) + min;
            }
            function getRandomFloat(min, max) {
                return (Math.random() * (max - min)) + min;
            }
            function getRandomChar() {
                return String.fromCharCode(getRandomInt(97, 122));// lower case
            }
            function getRandomString(min, max){
                let s = "";
                const length = getRandomInt(min, max);
                for(let i = 0; i < length; i++){
                    s += getRandomChar();
                }
                return s;
            }
            function testValue(min, max, type){
                if (type === "float" || type === "floatString"){
                    return getRandomFloat(min, max);
                } else if(type === "char"){
                    return getRandomChar();
                } else if(type === "string"){
                    return getRandomString(min, max);
                } else {// int intString
                    return getRandomInt(min, max);
                }    
            }        
            function generate(){
                const nDimensions = parseInt(document.getElementById("testDimensions").value);
                if(nDimensions > 1){
                    generate2();
                    return;
                }
                const p = document.getElementById("testResult");
                const length = parseInt(document.getElementById("testLength").value);

                const container = (document.querySelector(".test")).querySelector(".dimension");
                const options = container.querySelectorAll("input");
                const min = parseInt(options[0].value);
                const max = parseInt(options[1].value);
                const type = container.querySelector("select").value;
                
                let arr = [];
                for(let i = 0; i < length; i++){
                    arr.push(testValue(min, max, type));      
                }
                let joinedString;
                if(type === "intString" || type === "char" ||type === "string"){
                    joinedString = arr.map(str => `"${str}"`).join(",");
                } else if (type === "float") {
                    joinedString = arr.map(float => float.toFixed(2)).join(",");
                }else if (type === "floatString") {
                    joinedString = arr.map(float =>  `"${float.toFixed(2)}"`).join(",");
                } else if(type === "int"){
                    joinedString = arr.map(int => `${int}`).join(",");
                }
                //p.textContent = "[" + joinedString + "]"
                updateElementText(p, "[" + joinedString + "]")
            }
            function generate2(){
                const nDimensions = parseInt(document.getElementById("testDimensions").value);
                const p = document.getElementById("testResult");
                const length = parseInt(document.getElementById("testLength").value);
                let arr = [];
                for(let i = 0; i < length; i++){
                    let subArr = [];
                    for(let j = 0; j < nDimensions; j++){
                        const container = (document.querySelector(".test")).querySelector(".dimensions").children[j];
                        const options = container.querySelectorAll("input");
                        const min = parseInt(options[0].value);
                        const max = parseInt(options[1].value);
                        const type = container.querySelector("select").value; 
                        subArr.push(testValue(min, max, type));   
                    }
                    arr.push(subArr);
                }
                let joinedString = "";
                for(let i = 0; i < length; i++){
                    let subString = "";
                    for(let j = 0; j < nDimensions; j++){
                        let container = (document.querySelector(".test")).querySelector(".dimensions").children[j];
                        let type = container.querySelector("select").value;  
                        if(type === "intString" || type === "char" ||type === "string"){
                            subString += `"${arr[i][j]}",`
                        } else if (type === "float") {
                            subString += arr[i][j].toFixed(2) + ","
                        }else if (type === "floatString") {
                            subString += `"${arr[i][j].toFixed(2)}",`;
                        }else if(type === "int"){
                            subString += arr[i][j] + ","
                        }
                    }
                    subString = subString.slice(0, -1);// remove last ','
                    joinedString += "[" + subString + "],";
                }
                joinedString = joinedString.slice(0, -1);// remove last ','
                //p.textContent = "[" + joinedString + "]"
                updateElementText(p, "[" + joinedString + "]")
            }
            async function updateElementText(element, text){
                /*element.textContent = "";
                for(let i = 0; i < text.length; i++){
                    //element.textContent += text[i];
                    await type(text[i], element);
                }*/
                element.textContent = text;
            }
            function type(letter, el, delay = 1) {
                return new Promise((resolve, reject) => {
                    setTimeout(() => resolve (el.textContent += letter), delay);
                })
	        }
        </script>
    </body>
</html>